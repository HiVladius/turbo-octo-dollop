# Optimización de Performance en SPAs

Las aplicaciones SPA requieren atención especial al rendimiento para ofrecer experiencias óptimas.

## Code Splitting

Divide tu código en chunks más pequeños que se cargan bajo demanda.

### ¿Por qué es importante?

El **code splitting** es fundamental para reducir el tiempo de carga inicial de tu aplicación. En lugar de cargar todo el código de una vez, puedes dividirlo estratégicamente y cargarlo cuando sea necesario.

```typescript
// Carga perezosa en React
const Dashboard = React.lazy(() => import('./Dashboard'));

function App() {
  return (
    <Suspense fallback={<div>Cargando...</div>}>
      <Dashboard />
    </Suspense>
  );
}
```

## Lazy Loading

Carga componentes y módulos solo cuando son necesarios.

### Implementación en diferentes frameworks

**Angular:**
```typescript
const routes: Routes = [
  {
    path: 'admin',
    loadChildren: () => import('./admin/admin.module').then(m => m.AdminModule)
  }
];
```

**Vue:**
```javascript
const router = new VueRouter({
  routes: [
    {
      path: '/about',
      component: () => import('./views/About.vue')
    }
  ]
});
```

## Memoization

Usa técnicas de memoización para evitar cálculos innecesarios.

### React Hooks

```typescript
import { useMemo, useCallback } from 'react';

function ExpensiveComponent({ data }) {
  // Memoriza el resultado de un cálculo costoso
  const processedData = useMemo(() => {
    return data.map(item => expensiveOperation(item));
  }, [data]);

  // Memoriza una función callback
  const handleClick = useCallback(() => {
    console.log('Clicked!');
  }, []);

  return <div onClick={handleClick}>{processedData}</div>;
}
```

### Vue Computed Properties

```javascript
export default {
  computed: {
    filteredItems() {
      // Esta propiedad solo se recalcula si 'items' o 'filter' cambian
      return this.items.filter(item => item.type === this.filter);
    }
  }
}
```

## Virtual Scrolling

Para listas grandes, renderiza solo los elementos visibles.

### Implementación básica

```typescript
import { ScrollingModule } from '@angular/cdk/scrolling';

@Component({
  template: `
    <cdk-virtual-scroll-viewport itemSize="50" class="viewport">
      <div *cdkVirtualFor="let item of items" class="item">
        {{ item }}
      </div>
    </cdk-virtual-scroll-viewport>
  `
})
export class ListComponent {
  items = Array.from({ length: 100000 }).map((_, i) => `Item #${i}`);
}
```

## Métricas Clave de Rendimiento

### Core Web Vitals

1. **LCP (Largest Contentful Paint)**: < 2.5s
2. **FID (First Input Delay)**: < 100ms
3. **CLS (Cumulative Layout Shift)**: < 0.1

### Herramientas de Medición

- **Lighthouse**: Auditorías automatizadas de rendimiento
- **Chrome DevTools**: Profiling detallado
- **WebPageTest**: Testing en condiciones reales
- **Bundle Analyzer**: Análisis del tamaño de bundles

## Best Practices

### 1. Optimiza tus imágenes
- Usa formatos modernos (WebP, AVIF)
- Implementa lazy loading
- Proporciona imágenes responsive

### 2. Minimiza el JavaScript
- Usa tree-shaking
- Elimina código muerto
- Minifica tu código en producción

### 3. Aprovecha el Caché
- Implementa service workers
- Usa versioning en assets
- Configura headers de caché apropiados

### 4. Optimiza la Renderización
- Usa CSS-in-JS con cuidado
- Evita layout shifts
- Implementa skeleton screens

## Conclusión

La optimización del rendimiento en SPAs es un proceso continuo que requiere:

- **Medición constante** de métricas
- **Implementación estratégica** de técnicas de optimización
- **Balance** entre funcionalidad y rendimiento
- **Monitoreo** en producción

El rendimiento no es una característica, es una funcionalidad fundamental que impacta directamente en la experiencia del usuario y el éxito de tu aplicación.
